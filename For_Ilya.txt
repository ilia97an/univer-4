Aspect 1

Метод add должен быть определен в рамках класса Array и заключаются в получении результата без побочного эффекта. В операции участвуют два массива: первый - self, второй - аргумент метода. Метод может быть определен следующим образом

class Array
  def add b
    self.zip(b).map {|l| l.reduce(:+)}
  end
end

Может быть еще много вариантов определения этого метода. Например,

class Array
  def add b
    self.each_with_index.map {|a, i| a + b[i]}
  end
end

    Не следует ставить за решение более 0 баллов, если для каких-то двух числовых массивов a и b в результате выполнения

    c = a.add b

    изменяется a или b.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
Array 2
Определение класса Field, включая его инициализацию, может выглядеть следующим образом:

class Field
  def initialize
    @field = Array.new(FieldSize) {Array.new(FieldSize)}
  end

  FieldSize = 10

  ...
end

(порядок расположения определений метода initialize и константы FieldSize не имеет значения).

    В методе initialize должен корректно определяться двумерный массив. Если это не так, то решение заслуживает не более 0 баллов.
    В частности, если второе упоминание Array.new является вторым аргументом первого вызова Array.new, т.е. имеет место подобный вызов:

    @field = Array.new(FieldSize, Array.new(FieldSize))

    то решение заслуживает не более 0 баллов.
    Следует снизить оценку на 5 баллов, если в классе присутствует не предусмотренное заданием определение геттера/сеттера переменной состояния. 
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
Aspect 3

Метод size должен являться методом класса Field и возвращать значение константы FieldSize. То есть метод должен выглядеть следующим образом

def self.size
  FieldSize
end

    Решение заслуживает не более 0 баллов, если в заголовке метода отсутствует self..
    Решение заслуживает не более 0 баллов, если оно сложнее чем то, что представлено выше.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
Aspect 4

Метод set! может иметь следующий вид.

def set! (n, x, y, hor, ship)
  n.times do
    @field[x][y] = ship
    if hor then x += 1 else y += 1 end
  end
end

Может быть еще много вариантов определения этого метода. Например,

def set! (n, x, y, hor, ship)
  dims = [1, n]
  if hor then dims.reverse! end
  @field[x, dims[0]].each do |row| 
    row[y, dims[1]] = Array.new(dims[1], ship)
  end
end

    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
Aspect 5

Метод to_s может иметь следующий вид.

def to_s
  line = "+" + "-" * Field.size + "+"
  res = line + "\n"
  @field.each do |row|
    res += "|"
    row.each {|x| res += (!x ? " " : x.to_s)}
    res += "|\n"
  end
  res += line
end

    Следует снизить оценку на 2 балла, если вместо константы FieldSize или метода Field.size используется число 10 (или другое число, заданное литералом).
    Следует снизить оценку на 2 балла, если вместо методов-итераторов используется оператор цикла while.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Aspect 6

Метод print_field может иметь следующий вид.

def print_field
  puts to_s
end

    Следует снизить оценку за решение на 2 балла, если над результатом to_s производятся какие-то дополнительные действия.
    Следует снизить оценку за решение на 4 балла, если метод to_s не используется для получения результата.
    Не следует снижать оценку, если результат nil выдается явным образом.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
	
Aspect 7

Метод free_space? может иметь следующий вид.

def free_space? (n, x, y, hor)
  field_b = [x,y]
  dims = [0,n-1]
  if hor then dims.reverse! end
  field_e = field_b.add dims
  if (field_b + field_e).all? {|a| a.between?(0, FieldSize - 1)}
    dims = dims.add [1, 1]
    field_b.each_index do |i| 
      if field_b[i] > 0 
        field_b[i] -= 1
        dims[i] += 1
      end
    end
    field_e.each_index do |i| 
      if field_e[i] < FieldSize - 1 then dims[i] += 1 end
    end
    @field[field_b[0], dims[0]].all? do |row| 
      row[field_b[1], dims[1]].all? {|cell| !cell || cell == ship}
    end
  else
    false
  end
end

    Следует оценить решение не более чем в 0 баллов, если в методе не проверяется, что заданные координаты x и y находятся в диапазоне координат клеток игрового поля.
    Следует оценить решение не более чем в 0 баллов, если в методе не проверяется, что заданные параметры определяют корабль, полностью помещающийся в игровое поле.
    Следует снизить оценку на 2 балла, если вместо константы FieldSize или метода Field.size используется число 10 (или другое число, заданное литералом).
    Следует снизить оценку на 1 балл, если для какой-то клетки (для каких-то клеток) игрового поля дважды осуществляется проверка на то, что она свободна.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 7
5
Comment for Aspect 7
Aspect 8

Определение класса Ship, включая его инициализацию, может выглядеть следующим образом:

class Ship
  attr_reader :coord, :len

  def initialize(field, len)
    @len = len 
    @myfield = field
    @maxhealth = 100 * len
    @minhealth = 30 * len
    @health = @maxhealth
  end

  ...
end

(порядок расположения определений метода initialize и геттеров coord и len не имеет значения).

    Трудно представить себе решение сложнее, но если такое найдется, следует снизить оценку на 1 балл.
    Следует снизить оценку на 5 баллов, если в классе присутствует не предусмотренное заданием определение геттера/сеттера переменной состояния.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 8
5
Comment for Aspect 8
Aspect 9

Метод to_s в классе Ship должен иметь следующий вид.

def to_s 
  "X"
end

    Следует оценить решение не более чем в 0 баллов, если запуск метода возвращает что-то отличное от строки "X".
    Следует оценить решение не более чем в 0 баллов, если запуск метода выдает строку "X" на экран, а в качестве результата выдает nil (это случается, когда в теле метода присутствует вызов процедуры вывода на экран puts или print).
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 9
5
Comment for Aspect 9
Aspect 10

Метод clear должен иметь следующий вид.

def clear
  @myfield.set!(@len, @coord[0], @coord[1], @hor, nil)
end

    Следует оценить решение в 0 баллов, если в решении отсутствует вызов @myfield.set!.
    Не следует снижать оценку, если в качестве пятого параметра явно передается значение nil
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 10
5
Comment for Aspect 10
Aspect 11

Метод set! в классе Ship может иметь следующий вид.

def set! (x, y, hor)
  if @myfield.free_space?(@len, x, y, hor, self)
    if @coord then clear end
    @myfield.set!(@len, x, y, hor, self)
    dim = [0, @len - 1]
    if hor then dim.reverse! end
    @coord = [x, y] + ([x, y].add dim) 
    @hor = hor
    true
  else
    false
  end
end

    Следует оценить решение в 0 баллов, если в решении отсутствует любой из вызовов: @myfield.set!, @myfield.free_space?.
    Следует оценить решение в 0 баллов, если в решении в вызове @myfield.free_space? последним аргументом передается что-то отличное от self
    Следует оценить решение в 0 баллов, если в решении в вызове @myfield.set! последним аргументом передается что-то отличное от self
    Следует оценить решение в 0 баллов, если в решении нет ни вызова clear, ни вызова kill (снижать не нужно, если присутствует вызов какого-то из двух методов).
    Следует оценить решение в 0 баллов, если в результате метода в последних двух элементах массива @coord сохраняется нечто отличное от координат последней клетки корабля.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 11
5
Comment for Aspect 11
Aspect 12

Метод kill должен иметь следующий вид.

def kill
  clear
  @coord = nil
end  

    Следует снизить оценку на 2 балла, если в решении отсутствует вызов clear.
    Следует оценить решение не более чем в 0 баллов, если переменной @coord присваивается значение, отличное от nil.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 12
5
Comment for Aspect 12
Aspect 13

Метод explode должен иметь следующий вид.

def explode
  @health -= 70
  if @health <= @minhealth then 
    kill 
    return @len
  end
  nil
end

    Следует снизить оценку на 2 балла, если в решении отсутствует вызов kill.
    Следует оценить решение не более чем в 0 баллов, если при равенстве @health и @minhealth не происходит вызова kill (т.е. случай, эквивалентный приведенному решению, в котором нестрогое неравенство заменено на строгое).
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 13
5
Comment for Aspect 13
Aspect 14

Метод cure может иметь следующий вид.

def cure
  @health += 30
  if @health > @maxhealth then @health = @maxhealth end
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 14
5
Comment for Aspect 14
Aspect 15

Метод health может иметь следующий вид.

def health
  (100 * @health.to_f / @maxhealth).round(2)
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует оценить решение в 0 баллов, если перед делением ни к делимому, ни к делителю не применяется метод to_f (или числитель/знаменатель не превращается в вещественное число иным способом).
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 15
5
Comment for Aspect 15
Aspect 16

Метод move в классе Ship может иметь следующий вид.

def move forward 
  moves = [0, forward ? 1 : -1]
  if @hor then moves.reverse! end
  new_coord = @coord.add (moves + moves)
  set!(new_coord[0], new_coord[1], @hor)   
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 16
5
Comment for Aspect 16
Aspect 17

Метод rotate может иметь следующий вид.

def rotate (n, k)
  if n.between?(1, @len)
    new_hor = (k % 2 == 1) ? !@hor : @hor
    if k==1
      if @hor
        new_coord = [@coord[0] + n - 1, @coord[1] - n + 1]
      else
        new_coord = [@coord[2] + n - @len, @coord[3] + n - @len]
      end
      set!(new_coord[0], new_coord[1], new_hor)
    elsif k==2
      if @hor
        new_coord = [@coord[2] + 2 * n - 2* @len, @coord[3]]
      else
        new_coord = [@coord[2], @coord[3] + 2 * n - 2 * @len]
      end
      set!(new_coord[0], new_coord[1], new_hor)
    elsif k==3
      if @hor
        new_coord = [@coord[2] + n - @len, @coord[3] + n - @len]
      else
        new_coord = [@coord[0] - n + 1, @coord[1] + n - 1]
      end
      set!(new_coord[0], new_coord[1], new_hor)
    else
      false
    end
  else
    false
  end
end

    Следует оценить решение не более чем в 0 баллов, если в методе не проверяется, что заданные параметры n и k находятся в в необходимых диапазонах.
    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 17
0
Comment for Aspect 17
 -5баллов - В решении задания 17 метод rotate экземпляра класса Ship ведет себя некорректно на тесте

@a = Field.new
@b = Ship.new(@a,1)
@c = Ship.new(@a,4)
@b.set!(0,0,true)
@c.set!(5,5,true)
@b.rotate(2,2)
Aspect 18

Определение класса BattleField, включая его инициализацию, может выглядеть следующим образом:

class BattleField < Field
  def initialize
    super
    newships
  end

  Ships = [4,3,3,2,2,2,1,1,1,1]

  def newships
    @allships = Ships.map {|len| Ship.new(self, len)}
  end

  ...
end

(порядок расположения определений метода initialize, константы Ships и метода newships не имеет значения).

    Следует снизить оценку за решение на 1балл, если в методе initialize нет вызова super.
    Следует оценить решение не более чем в 0 баллов, если в методе newships вызову Ship.new в качестве первого аргумента вместо self передается что-то иное.
    Следует снизить оценку на 5 баллов, если в классе присутствует не предусмотренное заданием определение геттера/сеттера переменной состояния.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 18
5
Comment for Aspect 18
Aspect 19

Метод fleet может иметь следующий вид.

def fleet
  @allships.each_with_index.map {|x, i| [i, x.len]}
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует оценить решение в  0 баллов, если в решении не используется метод len объектов класса Ship.
    Следует оценить решение в  0 баллов, если в массив-результат вносятся в качестве первых элементов пар не номера элементов массива @allships а что-то иное.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 19
4
Comment for Aspect 19
-1 балл - Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
Aspect 20

Метод place_fleet может иметь следующий вид.

def place_fleet pos_list
  res = pos_list.inject(true) do |a, l|
    a && @allships[l[0]].set!(l[1], l[2], l[3])
  end
  if res
    res = @allships.inject(true) {|a, ship| a && ship.coord}
  end
  if !res 
    @allships.each {|ship| if ship.coord then ship.kill end}
  end
  res
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует оценить решение в  0 баллов, если в решении не используется метод set! объектов класса Ship.
    Следует оценить решение в  0 баллов, если в решении не используется метод kill объектов класса Ship.
    Следует оценить решение в  0 баллов, если в решении не используется метод coord объектов класса Ship.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 20
5
Comment for Aspect 20
Aspect 21

Метод remains может иметь следующий вид.

def remains
  @allships.each_with_index.map {|x, i| [i, x.coord, x.len, x.health]}
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует оценить решение в  0 баллов, если в решении не используется хотя бы один из методов объектов класса Ship: len, coord, health.
    Следует оценить решение в  0 баллов, если в массив-результат вносятся в качестве первых элементов четверок не номера элементов массива @allships а что-то иное.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 21
5
Comment for Aspect 21
Aspect 22

Метод refresh может иметь следующий вид.

def refresh
  @allships = @field.reduce(:|).find_all {|x| x}
end

Вопрос по заданию стоит: оставить в массиве только те корабли, которые размещены в игровом поле. Поэтому обновление массива должно исходить из содержимого игрововго поля, а не из исходного содержимого массива.

    Следует снизить оценку на 2 балла, если обновление массива происходит через анализ элементов массива, например:

    def refresh
      @allships = @allships.find_all {|x| x.coord}
    end

    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 22
0
Comment for Aspect 22
-5 баллов - Результат метода refresh класса BattleField в решении задания 22 не соответствует заданию. 
Aspect 23

Метод shoot может иметь следующий вид.

def shoot c
  if @field[c[0]][c[1]]
    if res = @field[c[0]][c[1]].explode
      refresh
      "killed #{res}"
    else
      "wounded"
    end
  else
    "miss"
  end
end

    Следует снизить оценку на 2 балла, если в методе не происходит прямого обращения к массиву @field.
    Следует оценить решение в  0 баллов, если в решении не используется хотя бы один из методов: explode, refresh.
    Следует оценить решение в  0 баллов, если в решении происходит прямое обращение к массиву @allships.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 23
5
Comment for Aspect 23
Aspect 24

Метод cure должен иметь следующий вид.

def cure
  @allships.each {|ship| ship.cure}
end

    Следует снизить оценку на 2 балла, если при правильной работе метода нет обращения к методу cure объекта класса Ship.
    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 24
5
Comment for Aspect 24
Aspect 25

Метод game_over? должен иметь следующий вид.

def game_over?
  @allships.empty?
end

    Следует оценить решение не более чем в 0 баллов, если вместо проверки пустоты массива @allships, т.е. наличия в нем 0 элементов, или сравнения его с пустым массивом [], массив сравнивается со значением nil.
    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 25
5
Comment for Aspect 25
Aspect 26

Метод move объектов класса BattleField может иметь следующий вид.

def move l_move
  if l_move[1].between?(1,3)
    @allships[l_move[0]].rotate(l_move[2], l_move[1])
  else
    @allships[l_move[0]].move(l_move[2] == 1)
  end
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 26
5
Comment for Aspect 26
Aspect 27

Определение класса Player, включая его инициализацию, может выглядеть следующим образом:

class Player
  attr_accessor :manual
  def initialize (name, manual = true)
    @name = name
    @manual = manual
    @lastsample = [1, 0]
    reset
  end

  def reset
    @lastshots = []
    @allshots = []
  end

  ...
end

(порядок расположения определений метода initialize, manual и reset не имеет значения).

    Следует снизить оценку на 2 балла, если у последнего параметра метода initialize не указано значение по умолчанию или значение по умолчанию отлично от заданного. 
    Следует снизить оценку на 5 баллов, если в классе присутствует не предусмотренное заданием определение геттера/сеттера переменной состояния.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 27
5
Comment for Aspect 27
Aspect 28

Метод to_s может иметь следующий вид.

def to_s
  @name
end

    Следует снизить оценку на 1 балл, если над переменной @name выполняются какие-то действия для получения результата.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 28
5
Comment for Aspect 28
Aspect 29

Метод random_point может иметь следующий вид.

def random_point
  [rand(Field.size), rand(Field.size)]
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует снизить оценку на 2 балла, если вместо значения метода Field.size используется число 10 (или другое число, заданное литералом).
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 29
3
Comment for Aspect 29
Следует снизить оценку на 2 балла, если вместо значения метода Field.size используется число 10 (или другое число, заданное литералом).
Aspect 30

Метод place_strategy может иметь следующий вид.

def place_strategy ship_list
  tmp_field = Field.new
  dirs = [true, false]
  res = []
  (ship_list.sort {|x,y| y[1] <=> x[1]}).each do |s|
    flag = false
    while !flag
      p = random_point
      hor = dirs.sample
      if tmp_field.free_space?(s[1], p[0], p[1], hor, s[0])
        tmp_field.set!(s[1], p[0], p[1], hor, s[0])
        res.push [s[0], p[0], p[1], hor]
        flag = true
      end
    end
  end
  res
end

    Следует снизить оценку на 2 балла, если вместо значения метода Field.size используется число 10 (или другое число, заданное литералом).
    Следует снизить оценку на 1 балл, если не используется метод random_point.
    Следует снизить оценку на 2 балла, если при выборе разворота корабля вместо случайного разворота отдается предпочтение одному из направлений (т.е. присутствует проверка: если можно поставить корабль в данном направлении, то поставить именно так, а иначе - только при невозможности первого).
    Следует оценить решение в  0 баллов, если расстановка кораблей ведется не в порядке убывания их длины. В связи с этим, обратите внимание, что метод sort, в отличие от sort!, не изменяет исходный массив, а выдает новый.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 30
4
Comment for Aspect 30
Следует снизить оценку на 1 балл, если не используется метод random_point.
Aspect 31

Методы hit и miss могут иметь следующий вид.

def hit message
  @lastshots.push [@shot, message]
end
def miss
  @allshots.push( hit("miss") )
  @lastshots = []
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Не следует снижать оценку, если в miss не используется hit.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 31
5
Comment for Aspect 31
Aspect 32

Необходимый фрагмент метода shot_strategy может иметь следующий вид.

if @lastshots.length == 0 || @lastshots[-1][1][0,6] == "killed"
  @shot = random_point
else 
  if @lastshots.length == 1 || @lastshots[-2][1][0,6] == "killed"
    @lastsample = [[0,1],[0,-1],[1,0],[-1,0]].sample
    @shot = @lastshots[-1][0]
  end
  @shot = @shot.add @lastsample
  if ! @shot.all? {|x| x.between?(0, Field.size-1)}
    @lastsample = @lastsample.map {|x| -x}
    @shot = (@lastshots[-1][0]).add @lastsample
  end
end
if @lastshots.any? {|x| x[0] == @shot}
  shot_strategy
else
  @shot
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует снизить оценку на 2 балла, если вместо значения метода Field.size используется число 10 (или другое число, заданное литералом).
    Следует снизить оценку на 1 балл, если не используется метод random_point.
    Следует снизить оценку на 2 балла, если при втором выстреле по одному кораблю вместо случайной соседней точки отдается предпочтение одному из направлений (т.е., например, только вправо от предыдущего выстрела).
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 32
0
Comment for Aspect 32
-5 баллов - В решении задания 32 метод shot_strategy экземпляра класса Player ведет себя некорректно на тесте

@b = Player.new("Ivan", false)
@l = [[[1, 1], "killed 1"], [[4, 5], "wounded"]]
@ls = [1, 0]
@st = [4, 5]
@b.instance_variable_set(:@lastshots,@l)
@b.instance_variable_set(:@shot,@st)
@b.instance_variable_set(:@lastsample,@ls)
@s = @b.shot_strategy
Aspect 33

Необходимый фрагмент метода ship_move_strategy может иметь следующий вид.

weakest = (remains.sort {|a, b| a[3] <=> b[3]})[0]
[weakest[0], rand(4), rand(1..weakest[2])]

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.

Grade for Aspect 33
0
Comment for Aspect 33
В решении задания 33 метод ship_move_strategy объекта класса Player возвращает некорректный результат в случае, если ship[0] != i
Aspect 34

Определение класса Game, включая его инициализацию, может выглядеть следующим образом:

class Game
  def initialize (player_1, player_2)
    @players= [[player_1, BattleField.new, 0], 
               [player_2, BattleField.new, 0]]
    @players.each {|p| reset p}
    @players.shuffle!
    @game_over = false
  end

  def reset p
    print(p[0], " game setup\n")
    p[0].reset
    player_ships = p[1].fleet
    if !p[1].place_fleet(p[0].place_strategy player_ships)
      raise "Illegal ship placement"
    else
      puts "Ships placed"
    end
  end

  ...
end

(порядок расположения определений методов initialize и reset не имеет значения).

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Следует оценить решение в 1 балл, если в initialize имеется не точно два вызова BattleField.new.
    Следует оценить решение в 1 балл, если первый ход делает всегда первый игрок, т.е. список игроков не перемешивается после инициализации. В связи с этим, обратите внимание, что метод shuffle, в отличие от shuffle!, не изменяет исходный массив, а выдает новый.
    Следует снизить оценку на 5 баллов, если в классе присутствует не предусмотренное заданием определение геттера/сеттера переменной состояния.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.


Grade for Aspect 34
5
Comment for Aspect 34
Aspect 35

Метод start может иметь следующий вид.

def start 
  lastshots = []
  while ! @game_over
    p1 = @players[0]
    p2 = @players[1]
    p1[2] += 1 
    print("Step #{p1[2]} of player ",p1[0], "\n")
    p1[1].cure
    p1[1].move (p1[0].ship_move_strategy p1[1].remains)
    shot = p1[0].shot_strategy
    if lastshots.include? shot
      puts "Illegal shot"
      res = "miss"
    else 
      lastshots.push shot
      res = p2[1].shoot shot
    end
    print(shot, " ", res, "\n")
    if res == "miss"
      p1[0].miss
      @players.reverse!
      lastshots = []
    else
      p1[0].hit res
      @game_over = p2[1].game_over?
      if @game_over
        puts "Player #{p1[0]} wins!"
        break
      end
    end
  end
end

    Следует снизить оценку на 1 балл, если решение сложнее, чем приведено в примере.
    Ваша оценка должна быть беспристрастной. Вполне нормально, если решение отличается от приведенных выше вариантов. Вы проверяете правильность решения и его стиль, а не степень совпадения решения с приведенными вариантами.
